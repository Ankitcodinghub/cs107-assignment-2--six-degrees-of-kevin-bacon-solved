# cs107-assignment-2--six-degrees-of-kevin-bacon-solved
**TO GET THIS SOLUTION VISIT:** [CS107 Assignment 2- Six Degrees of Kevin Bacon Solved](https://www.ankitcodinghub.com/product/cs107-2/)


---

üì© **If you need this solution or have special requests:** **Email:** ankitcoding@gmail.com  
üì± **WhatsApp:** +1 419 877 7882  
üìÑ **Get a quote instantly using this form:** [Ask Homework Questions](https://www.ankitcodinghub.com/services/ask-homework-questions/)

*We deliver fast, professional, and affordable academic help.*

---

<h2>Description</h2>



<div class="kk-star-ratings kksr-auto kksr-align-center kksr-valign-top" data-payload="{&quot;align&quot;:&quot;center&quot;,&quot;id&quot;:&quot;115110&quot;,&quot;slug&quot;:&quot;default&quot;,&quot;valign&quot;:&quot;top&quot;,&quot;ignore&quot;:&quot;&quot;,&quot;reference&quot;:&quot;auto&quot;,&quot;class&quot;:&quot;&quot;,&quot;count&quot;:&quot;1&quot;,&quot;legendonly&quot;:&quot;&quot;,&quot;readonly&quot;:&quot;&quot;,&quot;score&quot;:&quot;5&quot;,&quot;starsonly&quot;:&quot;&quot;,&quot;best&quot;:&quot;5&quot;,&quot;gap&quot;:&quot;4&quot;,&quot;greet&quot;:&quot;Rate this product&quot;,&quot;legend&quot;:&quot;5\/5 - (1 vote)&quot;,&quot;size&quot;:&quot;24&quot;,&quot;title&quot;:&quot;CS107 Assignment 2- Six Degrees of Kevin Bacon Solved&quot;,&quot;width&quot;:&quot;138&quot;,&quot;_legend&quot;:&quot;{score}\/{best} - ({count} {votes})&quot;,&quot;font_factor&quot;:&quot;1.25&quot;}">

<div class="kksr-stars">

<div class="kksr-stars-inactive">
            <div class="kksr-star" data-star="1" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="2" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="3" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="4" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" data-star="5" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>

<div class="kksr-stars-active" style="width: 138px;">
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
            <div class="kksr-star" style="padding-right: 4px">


<div class="kksr-icon" style="width: 24px; height: 24px;"></div>
        </div>
    </div>
</div>


<div class="kksr-legend" style="font-size: 19.2px;">
            5/5 - (1 vote)    </div>
    </div>
&nbsp;

When you think about Hollywood heavyweights, you don‚Äôt immediately think of Kevin

Bacon. But his career spans almost 20 years through films such as Flatliners, The Air Up There, Footloose, The River Wild, JFK and Animal House. So brush up on your Bacon lore. To play an Internet version, visit http://oracleofbacon.org/.

How to Play

The game takes the form of a trivia challenge. Propose two names, and your friend/opponent has to come up with a sequence of movies and mutual co-stars connecting the two. In this case, your opponent takes on the form of your computer, and the computer is exceptionally good.

Jack Nicholson and Meryl Streep? That‚Äôs easy:

Actor or actress [or &lt;enter&gt; to quit]: Jack Nicholson

Another actor or actress [or &lt;enter&gt; to quit]: Meryl Streep Jack Nicholson was in ‚ÄúHeartburn‚Äù (1986) with Meryl Streep.

Mary Tyler Moore and Red Buttons? Hmmm‚Ä¶ not so obvious:

Actor or actress [or &lt;enter&gt; to quit]: Mary Tyler Moore

Another actor or actress [or &lt;enter&gt; to quit]: Red Buttons

Mary Tyler Moore was in ‚ÄúChange of Habit‚Äù (1969) with Regis Toomey.

Regis Toomey was in ‚ÄúC.H.O.M.P.S.‚Äù (1979) with Red Buttons.

Barry Manilow and Lou Rawls?

Actor or actress [or &lt;enter&gt; to quit]: Barry Manilow

Another actor or actress [or &lt;enter&gt; to quit]: Lou Rawls

Barry Manilow was in ‚ÄúBitter Jester‚Äù (2003) with Dom Irrera.

Dom Irrera was in ‚ÄúMan Is Mostly Water, A‚Äù (2000) with Lou Rawls.

It‚Äôs the people you‚Äôve never heard of that are far away from each other:

Actor or actress [or &lt;enter&gt; to quit]: Carol Eby

Another actor or actress [or &lt;enter&gt; to quit]: Debra Muubu

Carol Eby was in ‚ÄúBottega dell‚Äôorefice, La‚Äù (1988) with Burt Lancaster.

Burt Lancaster was in ‚ÄúScalphunters, The‚Äù (1968) with Tony Epper (I). Tony Epper (I) was in ‚ÄúAlien from L.A.‚Äù (1988) with Debra Muubu.

Is it true? Your buffoon of a lecturer has a Bacon number of 3?

Actor or actress [or &lt;enter&gt; to quit]: Jerry Cain

Another actor or actress [or &lt;enter&gt; to quit]: Kevin Bacon

Jerry Cain was in ‚ÄúNo Rules‚Äù (2005) with Dian Bachar.

Dian Bachar was in ‚ÄúRocky &amp; Bullwinkle‚Äù (2000) with Robert De Niro.

Robert De Niro was in ‚ÄúSleepers‚Äù (1996) with Kevin Bacon.

I have no idea who this particular Jerry Cain is. Maybe you do.

Overview

There are two major components to this assignment:

‚Ä¢ You need to provide the implementation for an imdb class , which allows you to quickly look up all of the films an actor or actress has appeared in and all of the people starring in any given film. We could layer our imdb class over two STL maps‚Äîone mapping people to movies and another mapping movies to people‚Äîbut that would require we read in several megabytes of data from flat text files. That type of configuration takes several minutes, and it‚Äôs the opposite of fun if you have to sit that long before you play. Instead, you‚Äôll tap your sophisticated understanding of memory and data representation in order to look up movie and actor information very, very quickly. This is the meatier part of the assignment, and I‚Äôll get to it in a moment.

‚Ä¢ You also need to implement a breadth-first search algorithm that consults your super-clever imdb class to find the shortest path connecting any two actor/actresses. If the search goes on for so long that you can tell it‚Äôll be of length 7 or more, then you can be reasonably confident (and pretend that you know for sure that) there‚Äôs no path connecting them. This part of the assignment is more CS106B-like, and it‚Äôs a chance to get a little more experience with the STL and to see a legitimate scenario where a complex program benefits from two types paradigms: high-level C++ (with its templates and its object orientation) and lowlevel C (with its exposed memory and its procedural orientation.)

Task I: The imdb class

First off, I want to you complete the implementation of the imdb class. Here‚Äôs the interface:

struct film { string title; int year;

};

class imdb { public:

imdb(const string&amp; directory); bool getCredits(const string&amp; player, vector&lt;film&gt;&amp; films) const; bool getCast(const film&amp; movie, vector&lt;string&gt;&amp; players) const;

~imdb();

private:

const void *actorFile; const void *movieFile;

};

The constructor and destructor have already been implemented for you, because the manner in which I initialize the actorFile and movieFile fields to address the raw data representations uses some nontrivial UNIX. They each take O(1) time to run, because typically you want constructors and destructors to be as lightweight as possible. You need to implement the getCredits and getCast methods by manually crawling over these raw data representations in order to produce vectors of films and actor names. When properly implemented, they provide lightning-speed access to a gargantuan amount of information.

Understand up front that you are implementing these two methods to crawl over two arrays of bytes in order to synthesize data structures for the client. What follows below is a description of how the memory is laid out. You aren‚Äôt responsible for creating the data files in any way; you‚Äôre just responsible for understanding how everything is encoded so that you can re-hydrate information from byte-level representations.

The Raw Data Files

The actorFile and movieFile fields each address gigantic blocks of memory. They are each configured to point to mutually referent databases, and the format of each is described below. The imdb file constructor sets these pointers up for you, so you can proceed as if everything is set up for getCast/Credits to just run.

For the purposes of illustration, let‚Äôs assume that Hollywood has produced a mere three movies, and that they‚Äôve always rotated through the same three actors whenever the time came to cast their three films. Let‚Äôs pretend those three films are as follows:

Clerks, released in 1993, starring Cher and Liberace.

Moonstruck, released in 1988, starring Cher, Liberace, and Madonna.

Zoolander, released in 1999, starring Liberace and Madonna.

Remember, we‚Äôre pretending.

If the imdb were configured to store the above information, you could imagine its actorFile and movieFile fields being initialized (by the constructor I already wrote for you) as follows:

However, each of the records for the actors and the movies will be of variable size. Some movie titles are longer than others; some films feature 75 actors, while others star only a handful. Some people have prolific careers, while several people are one-hit wonders. Defining a struct or class to overlay the blocks of data would be a fine idea, except that doing so would constrain all records to be the same size. We don‚Äôt want that, because we‚Äôd be wasting a good chunk of memory when storing information on actors who appeared in just one or two films (and for films that feature just a handful of actors.)

However, by allowing the individual records to be of variable size, we lose our ability to binary search a sorted array of records. The number of actors is well over 300,000; the number of movies is some 124,000, so linear search would be slow. All of the actors and movies are sorted by name (and then by year if two movies have the same name), so binary search is still within our reach. The strong desire to search quickly motivated my decision to format the data files like this:

Spliced in between the number of records and the records themselves is an array of integer offsets. They‚Äôre drawn as pointers, but they really aren‚Äôt stored as pointers. We want the data images to be relocatable‚Äîthat is, we want the information stored in the data images pointed to by actorFile and movieFile to be useful, regardless of what addresses get stored there. By storing integer offsets, we can manually compute the location of Cher‚Äôs record, Madonna‚Äôs record, or Clerk‚Äôs record, etc, by adding the corresponding offsets to whatever actorFile or movieFile happens to be. A more accurate picture of what gets stored (and this is really what the file format is) is presented here.

Because the numbers are what they are, we would expect Cher‚Äôs 16-byte record to sit 16 bytes from the front of actorFile, Liberace‚Äôs 24-byte record to sit 32 bytes within the actorFile image, and so forth. Looking for Moonstruck? Its 28-byte record can be found 36 bytes ahead of whatever address is stored in movieFile. Note that the actual offsets tell me where records are relative to the base address, and the deltas between offsets tell me how large the actual records are.

Because all of the offsets are stored as four byte integers, and because they are in a sense sorted if the records they reference are sorted, we can use binary search. Woo!

To summarize:

‚Ä¢ actorFile points to a large mass of memory packing all of the information about all of the actors into one big blob. The first four bytes store the number of actors (as an int); the next four bytes store the offset to the zeroth actor, the next four bytes store the offset to the first actor, and so forth. The last offset is followed by the zeroth record, then the first record, and so forth. The records, even though variable in length, are sorted by name.

‚Ä¢ movieFile also points to a large mass of memory, but this one packs the information about all films ever made. The first four bytes store the number of movies (again, as an int); the next *(int *)movieFile * 4 bytes store all of the int offsets, and then everything beyond the offsets is real movie data. The movies are sorted by title, and those sharing the same title are sorted by year.

‚Ä¢ The above description above generalizes to files with 300,000 actors and 100,000 movies. The rules are the same.

The Actor Record

The actor record is a packed set of bytes collecting information about an actor and the movies he‚Äôs appeared in. We don‚Äôt use a struct or a class to overlay the memory associated with an actor, because doing so would constrain the record size to be constant for all actors. Instead, we lay out the relevant information in a series of bytes, the number of which depends on the length of the actor‚Äôs name and the number of films he‚Äôs appeared in. Here‚Äôs what gets manually placed within each entry:

1. The name of the actor is laid out character by character, as a normal nullterminated C-string. If the length of the actor‚Äôs name is even, then the string is padded with an extra ‚Äù so that the total number of bytes dedicated to the name is always an even number. The information that follows the name is most easily interpreted as a short integer, and virtually all hardware constrains any address manipulated as a short * to be even.

2. The number of movies in which the actor has appeared, expressed as a two-byte short. (Some people have been in more than 255 movies, so a single byte just isn‚Äôt enough.) If the number of bytes dedicated to the actor‚Äôs name (always even) and the short (always 2) isn‚Äôt a multiple of four, then two additional ‚Äù‚Äôs appear after the two bytes storing the number of movies. This padding is conditionally done so that the 4-byte integers than follow sit at addresses that are multiples of four.

3. An array of offsets into the movieFile image, where each offset identifies one of the actor‚Äôs films.

Here‚Äôs what Cher‚Äôs record would look like:

The movie record is only slightly more complicated. The information that needs to be compressed is as follows:

1. The title of the movie, terminated by a ‚Äù so the character array behaves as a normal C-string.

2. The year the film was released, expressed as a single byte. This byte stores the year ‚Äì 1900. Since Hollywood is less than 28 years old, it was fine to just store the year as a delta from 1900. If the total number of bytes used to encode the name and year of the movie is odd, then an extra ‚Äù sits in between the one-byte year and the data that follows.

3. A two-byte short storing the number of actors appearing in the film, padded with two additional bytes of zeroes if needed.

4. An array of four-byte integer offsets, where each integer offset identifies one of the actors in the actorFile. The number of offsets here is, of course, equal to the short integer read during step 3.

One major gotcha: Some movies share the same title even though they are different. (The Manchurian Candidate, for instance, was first released in 1962, and then remade in 2004. They‚Äôre two different films with two different casts.) If you look in the imdb-utils.h file, you‚Äôll see that the film struct provides operator&lt; and operator== methods. That means that two films know how to compare themselves to each other using infix == and &lt; (though not using !=, &gt;, &gt;=, or &lt;=). You can just rely on the &lt; and == to compare two film records. In fact, you should, because the movies in the movieData binary image are sorted to respect film::operator&lt;.

It‚Äôs best to work on the implementation of the imdb class in isolation, not worrying about the details of the search algorithm you‚Äôll eventually need to write. I‚Äôve provided a test harness to exercise the imdb all by itself, and that code sits in imdb-test.cc. The make system generates an test application called imdb-test which you can use to verify that your imdb implementation is solid. I provide sample versions of this imdb-test thing for both Solaris and for Linux, so you can run your version and my version side by side and make sure they match character for character.

Task II: Implementing Search

You‚Äôre back in C++ mode. At this point, I‚Äôm assuming your imdb class just works, and the fact that there‚Äôs some exceedingly shrewd pointer gymnastics going on in the imdb.cc file is completely disguised by the simple imdb interface. Use the services of your imdb and my path to implement a breadth-first search for the shortest possible path. Leverage off the STL containers as much as possible to get this done. Here are the STL classes I used in my solution:

‚Ä¢ vector&lt;T&gt;: there‚Äôs no escaping this one, because the imdb requires we pull films and actors out of the binary images as vectors.

‚Ä¢ list&lt;T&gt;: The list is a doubly-linked list that provides O(1) push_back, front, and pop_front operations. There‚Äôs also a queue template, and you can use that if you want, but I‚Äôm so bugged that the STL queue calls its methods push and pop instead of enqueue and dequeue that I boycotted it and used the list instead.

‚Ä¢ set&lt;T&gt;: I used two sets to keep track of previously used actors and films. If you‚Äôre implementing a breadth-first search and you encounter a movie or actor that you‚Äôve seen before, there‚Äôs no reason to use it/him/her a second time. You shouldn‚Äôt need to use anything other than set&lt;T&gt;::insert.

The dinkumware web site provide a clear, nicely formatted presentation of the list, vector, and set templates. You don‚Äôt need to read up on every method‚Äîjust the ones you know have to exist in order for them to be useful. There‚Äôs a link to the relevant part dinkumware on the CS107 web page.

Here‚Äôs the general algorithm I used for my own generateShortestPath function:

list&lt;path&gt; partialPaths; // functions as a queue set&lt;string&gt; previouslySeenActors; set&lt;film&gt; previouslySeenFilms;

create a partial path around the start actor; add this partial path to the queue of partial paths; while queue isn‚Äôt empty and its front element is of length 5 or less pull off front path (involves both front and pop_front) look up last actor‚Äôs movies for each movie in his/her list of movies you‚Äôve not seen before add movie to the set of previously seen movies look up movie‚Äôs cast for each cast member you‚Äôve not seen before add cast member to set of those previously seen clone the partial path add the movie/costar connection to the clone if you notice the costar is your target, then print the path and return otherwise add this new partial path to the end of the queue

if the while loop ends, print that you didn‚Äôt find a path

There are many clever optimizations that can be made, and I go through a few of them below. But you‚Äôre only expected to implement a search that‚Äôs consistent with the algorithm above.

How To Proceed

Seven days is a good stretch of time, but you have a lot to do. If you aren‚Äôt proactive in making the development process as easy as possible, you‚Äôre going to end up spending twice as much time as everyone else. Here‚Äôs the best advice I can give you:

‚Ä¢ Compile the starting files to see how they work. Read all of the provided interface files to understand not only what they do, but also how they will contribute to the final product. Work on the imdb class first, test it using the imdb-test.cc file, and work to match my sample application‚Äôs output exactly. Only after you‚Äôve nailed the imdb implementation should be move on to the search.

‚Ä¢ Development incrementally. Divide the process up to include several intermediate milestones (and when I say several, I mean on the order of 20 or 30.) Let your code base evolve into the program it needs to be.

‚Ä¢ Compile and test often. Never write more than a few new lines of code without compiling and testing to see that your changes work as intended. In general, I never write more than 10 ‚Äì 15 lines without compiling and executing to see how my code changed. If you write 100 lines of code, I guarantee you‚Äôll have more compiler errors than you can count on both hands. You don‚Äôt want that. You just don‚Äôt.

Getting started

Create a local working directory in your leland space where you‚Äôd like to consolidate all of your Assignment 2 files. Then type the following commands:

&gt; cp -r /usr/class/cs107/assignments/assn-2-six-degrees/ . (note the dot) &gt; cd assn-2-six-degrees

All of the Assignment 2 starter files will be copied into the current directory. In particular, you will see a Makefile, several header files, and several source files‚Äîall of which will contribute to your program development efforts. Here‚Äôs a list of the files that pertain to each task:

Task I

Here‚Äôs the subset of all the files that pertain to just the first of the two tasks:

imdb-utils.h The definition of the film struct, and an inlined function that finds the data files for you. You shouldn‚Äôt need to change this file.

imdb.h The interface for the imdb class. You shouldn‚Äôt change the public interface of this file, though you‚Äôre free to change the private section if it makes sense to.

imdb.cc The implementation of the imdb class constructor, destructor, and methods. This is where your code for getCast and getCredits belongs.

imdb-test.cc The unit test code we‚Äôve provided to help you exercise your imdb. You shouldn‚Äôt have to change this file. We‚Äôve provided sample applications called imdb-test-solaris and imdb-test-linux so you know what you‚Äôre working toward.

Makefile By typing make imdb-test, you‚Äôll compile just the files needed to build imdb-test. You shouldn‚Äôt need to change the Makefile at all.

Task II

Everything from Task I (except imdb-test.cc) contributes to the overall six-degrees application. Type make six-degrees to build the six-degrees executable without building the imdb-test application (or you can just type make and build both.) There are sample six-degrees-solaris and six-degrees-linux applications for you to play with. In addition to the files used for Task I, there are these:

six-degrees.cc The file where most if not all of your Task II changes should be

made.

path.h The definition of the path class, which is a custom class useful for building paths between two actors. You‚Äôre free to add methods if you think it‚Äôs sensible to do so.

path.cc The implementation of the path class. Again, you can add stuff here if you think it makes sense to.

Speeding It Up

You‚Äôre more than encouraged (though not required) to optimize the search to find paths‚Äîparticularly those between actors who are far apart from one another‚Äîmuch more quickly. Consider how neat it‚Äôd be if the application:

‚Ä¢ starts the search from the actor with the smaller number of movies, and reversing the final path if need be. You‚Äôll note that the path class provides a nice little reverse method for just this. In fact, your sample application does this

(though you don‚Äôt need to if you don‚Äôt want to.)

‚Ä¢ caches the results of all imdb method calls using local maps‚Äîone of type map&lt;string, vector&lt;film&gt; &gt;, and a second of type (can you guess?) map&lt;film, vector&lt;string&gt; &gt;. Before going to the imdb, you can see whether or not you‚Äôve looked up the same actor or movie on previous searches. If you have, you can more quickly return the stored result without committing to the more intense getCredits or getCast call.

‚Ä¢ uses a bidirectional search from both actor endpoints, building larger and larger search trees from each of them, and seeing if any of their branches touch. This is a very effective way of focusing the search so that paths of length 4, 5, and 6 can be more quickly discovered. Email me if you want some more details on this one. This last optimization is substantial and can get you some extra credit if done nicely.

Electronic submission

You‚Äôll submit this assignment and all subsequent programming assignments they way you submitted RSG. Just type /usr/class/cs107/bin/submit and you can‚Äôt go wrong.
